@layer components {
  /**
   * Anything that wants to look like a label.
   */
  .input-label {
    display     : block;
    user-select : none;

    &.required::after {
      display             : inline-block;
      content             : "*";
      margin-inline-start : --spacing(1);
      color               : var(--color-danger);
    }

    &.disabled {
      opacity : 0.6;
      cursor  : not-allowed;
    }
  }


  /**
   * The combination of a label + input element. Mostly used to control the
   * relative layout of the two elements.
   */
  .input-label-pair {
    display          : flex;
    flex-direction   : column;
    gap              : --spacing(1);
    margin-block-end : --spacing(1);

    &.label-before, &.label-after {
      flex-direction : row;
      align-items    : center;
      gap            : --spacing(3);
    }

    &.label-after, &.label-below {
      .input-label {
        order: 2;
      }
    }
  }


  /**
   * The message that is displayed for an input when its value is not valid.
   * The height here is intentionally 0 - having a validation that appears and
   * pushes everything else on the page down is annoying. This relies on there
   * being adequate gap between elements on the page, but IMO looks better.
   */
  .input-validation {
    color      : var(--color-danger);
    font-size  : var(--text-sm);
    line-clamp : 2;
    height     : 0;
  }


  /**
   * An input field is an element that contains:
   * 1) a label
   * 2) some sort of control, e.g., a text field, checkbox, etc
   * 3) a validation message
   */
  .input-field {
    display        : flex;
    flex-direction : column;
  }


  /**
   * Dedicated input-control styling, regardless of where it appears or
   * what it is inside of.
   */
  .input-control {
    flex-grow : 1;
    padding   : --spacing(2) --spacing(3);

    &::placeholder, .placeholder {
      color: var(--color-global-foreground-accent);
    }
  }


  /**
   * Dedicated input-group styling, regardless of where it appears or what it is inside
   * of. The input-group class name is to be used on a container element - most
   * typically a div - that contains an <input> and optionally one or more
   * .input-group-addon styled elements (or various other elements that Primevue throws
   * into the mix, but serve a similar purpose).
   */
  .input-group {
    display     : flex;
    align-items : center;

    &.input-group-loading {
      cursor: wait;
    }

    .input-group-addon {
      padding : 0 --spacing(2);
      color   : var(--color-global-foreground-accent);
    }

    button.input-group-addon {
      cursor: pointer;
    }

    .input-control {
      outline: none;
    }
  }


  /**
   * The base styles of things that look like an input field.
   */
  .input-group,
  .input-control:where(:not(.input-group .input-control)) {
    width               : 100%;
    overflow            : clip;
    background-color    : var(--color-global-background);
    outline             : solid 2px var(--color-background-scale-e);
    border-radius       : --spacing(1);
    transition          : color, background-color, outline-color, box-shadow;
    transition-duration : calc(var(--default-transition-duration) * 2);
    cursor              : pointer;

    /**
     * To explain all of the "is disabled and if not readonly" stuff below.
     * Some controls, like the Select, are completely custom widgets that don't
     * have a separate idea of "readonly" that can be toggled when the form is
     * submitted. This gives us a way to co-opt the disabled "you can't interact
     * with this right now" logic, and combine it with readonly styling.
     *
     * Also note, the `p-hidden-accessible` class is provided by the Primevue in
     * some circumstances. The MultiSelect component, for example, uses a visually
     * hidden input field. These fields are also marked readonly, so the logic
     * explained above does not work unless this is also taken into account.
     */

    /**
     * Readonly
     */
    &:where(.readonly, [readonly]:not(.p-hidden-accessible input), :is(.readonly &)) {
      cursor: default;
    }

    /**
     * Not Readonly
     */
    &:not(:where(.readonly, [readonly]:not(.p-hidden-accessible input), :is(.readonly &))) {

      /**
       * Disabled
       */
      &:where(.disabled, :disabled:not(.p-hidden-accessible input), :is(.disabled &)) {
        cursor  : not-allowed;
        opacity : 0.6;
      }

      /**
       * Not Disabled
       */
      &:not(:where(.disabled, :disabled:not(.p-hidden-accessible input), :is(.disabled &))) {
        &:hover, &:focus-within {
          outline-color: var(--color-global-foreground-accent);
        }

        &:focus-within {
          box-shadow: var(--shadow-heavy);
        }

        /* Don't style the backgrounds of some controls */
        &:not(:has(> input[type="checkbox"]), .input-button-bar):focus-within {
          background-color : var(--color-background-scale-b);
        }
      }
    }
  }


  /**
   * Checkboxes
   */
  .input-group:where(:has(input[type="checkbox"])) {
    position    : relative;
    user-select : none;
    flex-shrink : 0;
    width       : 1.5rem;
    height      : 1.5rem;

    /* !important is to overwrite what gets attached to i-* icons in the utility layer */
    svg, span[class^="i-"] {
      display     : block !important;
      line-height : 1;
      font-size   : 1rem;
      width       : 1rem !important;
      height      : 1rem !important;
      margin-left : 0.25rem;
    }

    input {
      appearance : none;
      position   : absolute;
      height     : 100%;
      inset      : 0;
      z-index    : 10;
      opacity    : 0;

      &:not(:disabled, [readonly]) {
        cursor: pointer;
      }
    }

    /**
     * A checkbox styled like a toggle switch.
     */
    &.toggle-switch {
      border-radius : 1rem;
      width         : 2.5rem;

      &:has(:checked) {
        .slider:before {
          background-color : var(--color-global-foreground);
          transform        : translateX(1rem);
        }
      }

      .slider {
        position      : absolute;
        inset         : 0;
        border-radius : 1rem;

        &:before {
          content             : '';
          position            : absolute;
          background-color    : var(--color-background-scale-d);
          border-radius       : var(--radius-full);
          width               : 1rem;
          height              : 1rem;
          top                 : 0.25rem;
          left                : 0.25rem;
          transition          : transform, background-color;
          transition-duration : var(--default-transition-duration);
          box-shadow          : var(--shadow-md);
        }
      }
    }
  }


  /**
   * The flyout of a form control like a Select or MultiSelect.
   */
  .input-menu {
    .input-group, .input-control {
      background-color: transparent;
    }

    .input-group:where(:has(input[type="checkbox"])) {
      height : 1.2rem;
      width  : 1.2rem;

      svg, span[class^="i-"] {
        margin-left : 0.1rem;
        margin-top  : -0.1rem;
      }

      [aria-disabled="true"] &:hover, [aria-disabled="true"] &:focus-within {
        outline-color: var(--color-background-scale-e) !important;

        input {
          cursor: not-allowed !important;
        }
      }
    }
  }


  /**
   * An input menu header can appear above option lists for components like Select
   * and MultiSelect. They may contain controls like a filter and/or (de)select all.
   */
  .input-menu-header {
    display     : flex;
    align-items : center;
    gap         : --spacing(2);

    .input-menu-filter {
      display     : flex;
      flex-grow   : 1;
      align-items : center;
      color       : var(--color-global-foreground-accent);
      transition  : color var(--default-transition-duration) var(--default-transition-timing-function);

      input {
        outline   : none;
        flex-grow : 1;
        padding   : --spacing(0.5) 0;

        &::placeholder {
          color: var(--color-global-foreground-accent);
        }
      }

      &:focus-within {
        color: var(--color-global-foreground);
      }
    }
  }


  /**
   * Button bars
   */
  .input-button-bar {
    width   : fit-content;
    padding : --spacing(0.5);
    gap     : --spacing(0.5);

    button {
      padding    : --spacing(1.5) --spacing(2);
      cursor     : pointer;
      transition : background-color var(--default-transition-duration) var(--default-transition-timing-function);

      &[aria-pressed="true"] {
        background-color: var(--color-background-scale-f);
      }

      &:where(.readonly button) {
        cursor: default;
      }

      &:disabled:not(:where(.readonly button)) {
        cursor  : not-allowed;
        opacity : 0.6;
      }

      &:not(:disabled, :where(.readonly button), [aria-pressed="true"]) {
        &:hover, &:focus-visible {
          background-color: var(--color-background-scale-b);
        }
      }

      &:first-child {
        border-top-left-radius    : var(--radius-sm);
        border-bottom-left-radius : var(--radius-sm);
      }

      &:last-child {
        border-top-right-radius    : var(--radius-sm);
        border-bottom-right-radius : var(--radius-sm);
      }
    }
  }
}
